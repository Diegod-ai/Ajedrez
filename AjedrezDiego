#lang racket

( require graphics/graphics )
(open-graphics) 
(define ventana1 (open-viewport "Ajedrez"  500 600))


(define (dibujar a b e)
  (if (> e 8)
      ((draw-rectangle ventana1) (make-posn 49 49) 401 401 "black")
      (if (> a 400)
          (dibujar 50 (+ b 50) (+ e 1))
          (begin
            (if(odd? e)
               (if(odd?(/ a 50))
                  (dibujar(+ a 50)b e)
                  (begin
                    ((draw-solid-rectangle ventana1)(make-posn a b)50 50 "slate blue")
                    (dibujar(+ a 50)b e))     
                  )
                (if(odd?(/ a 50))
                  (begin
                    ((draw-solid-rectangle ventana1)(make-posn a b)50 50 "slate blue")
                    (dibujar(+ a 50)b e))
                  (dibujar(+ a 50)b e))        
               )
            )
          )
      )
  )

(define table (dibujar 50 50 1))


;fichas blancas
(define BishopW   "WhitePieces/whiteBishop.png")
(define KnightW "WhitePieces/whiteKnight.png")
(define rookW   "WhitePieces/whiteRook.png")
(define kingW     "WhitePieces/whiteKing.png")
(define queenW   "WhitePieces/whiteQueen.png")
(define pawnW    "WhitePieces/whitePawn.png" )


;fichas negras
(define BishopB   "BlackPieces/blackBishop.png")
(define KnightB "BlackPieces/blackKnight.png")
(define rookB   "BlackPieces/blackRook.png")
(define kingB     "BlackPieces/blackKing.png")
(define queenB   "BlackPieces/blackQueen.png")
(define pawnB "BlackPieces/blackPawn.png" )
 

;finalizar de llamar fichas negras

;PieceAsignament evalua el caracter que se encuentra en otra funcion y lo evalua con un caracter que
;se refiere a una pieza del ajedrez, y despues le afilia una imagen 
( define ( PieceAsignament char)
  ( if ( equal? char #\T)
      rookB
      ( if ( equal? char #\C)
          KnightB
          ( if ( equal? char #\A)
              BishopB
              ( if ( equal? char #\D)
                  queenB
                  (if ( equal? char #\R )
                      kingB
                      (if ( equal? char #\P )
                          pawnB
                          ( if ( equal? char #\t)
                               rookW
                               ( if ( equal? char #\c)
                                    KnightW
                                    ( if ( equal? char #\a)
                                         BishopW
                                         ( if ( equal? char #\d)
                                              queenW
                                              (if ( equal? char #\r)
                                                  kingW
                                                  (if ( equal? char #\p )
                                                      pawnW 
                                                      "";else
                                                  ) ;end if ( equal? char #\p)
                                              ) ;end if ( equal? char #\r)        
                                         ) ;end if ( equal? char #\d)             
                                    ) ;end if ( equal? char #\a)                  
                               ) ;end if ( equal? char #\c)                       
                          ) ;end if ( equal? char #\t)
                      ) ;end if ( equal? char #\P) 
                  ) ;end if ( equal? char #\R)
              ) ;end if ( equal? char #\D)
          ) ;end if ( equal? char #\A)
      ) ;end if ( equal? char #\C)
  ) ;end if ( equal? char #\T)
) ;endFunction PieceAsignament

; InicialTable nos muestra el tablero inicial
(define inicialTable (string-append
                   "TCADRACT"
                   "PPPPPPPP"
                   "xxxxxxxx"
                   "xxxxxxxx"
                   "xxxxxxxx"
                   "xxxxxxxx"
                   "pppppppp"
                   "tcadract"))


;;Creamos la funcion PiecePut que sirve para poner la ficha en su lugar correspondiente
;;comparando cada parte de la funcion "InicialTabl"

 (define (PiecePut str count)
  (if (< count (string-length str))
        (if (not (equal? (string-ref str count) #\x))
            (begin
              (((draw-pixmap-posn (PieceAsignament (string-ref str count))) ventana1) (make-posn (* (+ 1 (remainder count 8)) 50) (* (+ 1 (quotient count 8)) 50)))
              (PiecePut str (+ count 1))
            );endBegin and start else
               (PiecePut str (+ count 1))
        );end (if (not (equal? (string-ref str count) #\x)) and start else
        (void)        
  );end (if (< count (string-length str))
 ); EndFunction PiecePut

(PiecePut inicialTable 0)


;;Aqui pedimos el click lo guardamos en el identificador "ubicacion"
(define ubicacion (get-mouse-click ventana1))
;; definimos la posicion x como "a" y hacemos esa operacion para que nos de el valor
;;de la columna en la que se encuentra posicionada
(define x (quotient (posn-x (mouse-click-posn ubicacion)) 50))
;; definimos la posicion y como "b" y hacemos esa operacion para que nos de el valor
;;de la fila en la que se encuentra posicionada
(define y (quotient (posn-y (mouse-click-posn ubicacion)) 50))
(define (casilla) ( - (+ x (* 8 y ) ) 9 ) )

 (define (colorComprobant)
  (if ( or (equal? (string-ref inicialTable (casilla)) #\T ) (equal? (string-ref inicialTable (casilla)) #\C )
         (equal? (string-ref inicialTable (casilla)) #\A ) (equal? (string-ref inicialTable (casilla)) #\D )
         (equal? (string-ref inicialTable (casilla)) #\R ) (equal? (string-ref inicialTable (casilla)) #\P ));EndCondition or
   ;Si la pieza es negra devolvera un 1
    1 ; else
    
   (if ( or (equal? (string-ref inicialTable (casilla)) #\t ) (equal? (string-ref inicialTable (casilla)) #\c )
         (equal? (string-ref inicialTable (casilla)) #\a ) (equal? (string-ref inicialTable (casilla)) #\d )
         (equal? (string-ref inicialTable (casilla)) #\r ) (equal? (string-ref inicialTable (casilla)) #\p ));EndCondition or
    ;si la pieza es blanca devolvera un 2 
      2 ; else

      ; en caso contrario, no devuelve nada
      0
   ); Endif que comprueba que las fichas son negras
  ); Endif que comprueba que las fichas son Blancas
 ); EndFunction colorComprobant


  ;;Movimiento de peones
  (define (pawnMovement)

     ;; Esta condicion sirve para corroborar la pieza que se quiere mover segun el turno
     ;; Si esta condicion es correcta, se moveran los peones negros 
    ( if ( and ( = (colorComprobant ) 1 )  ( equal? (string-ref inicialTable ) #\P))
       
        "vas a mover un peon negro"; else
     ;; De lo contrario, revisa si los peones son blancos para poder moverlos 
           ( if ( and ( = (colorComprobant ) 2) ( equal? (string-ref inicialTable ) #\p)) 
          
             "vas a mover un peon blanco"
     ;; Si ninguna de las dos se cumple significa que no esta querieno mover un peon
     ;; Esto es el reemplazo temporal de la llamada recursiva para evitar perder el turno y mover cualquier ficha 
             "No es un peon blanco"
           ); EndIf Movimiento de las fichas blancas
    ); EndIf Movimiento de las fichas negras
  ); EndFunction pawnMovement

  
 ;;Esta condicion solo sirve para el incio del juego, avisar al jugador que deben empezar las piezas blancas 
 (if (not (equal? (colorComprobant) 2 ))
    (begin
      (printf "Recuerde que siempre empiezan las blancas ")
      (colorComprobant )
    );endBegin 
    ; En caso contrario
    (pawnMovement)
    
 );endIf

; Este identificador sirve para iniciar el juego, ahora solo nos mostrara el comprobante de que empiezan los peones blancos
 (define (TurnComprobant )
  (if ( = (colorComprobant) 1 )
      (pawnMovement)
    (if ( = (colorComprobant) 2 )
        (pawnMovement)
        "Debe seleccionar una casilla con su ficha"
    ); EndIf ( = (colorComprobant) 2 )
   ); EndIf ( = (colorComprobant) 1 )
 ); EndFunction TurnComprobant



